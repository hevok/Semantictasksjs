//@ sourceMappingURL=collab.map
// Generated by CoffeeScript 1.6.1

/*
# SocketEvent class #
Socket Event class is a class that does all conversions and packing of events send by sockets and channels
*/


(function() {
  var _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.SocketEvent = (function() {
    /*
    Socket Event class is a class that does all conversions and packing of events send by sockets and channels
    it contains a lot of useful static helpers to generate events that needed
    */

    function SocketEvent(content, channel, request, room) {
      this.content = content;
      this.channel = channel;
      this.request = request != null ? request : "push";
      this.room = room != null ? room : "all";
      /*
        creates websocket event where
        content is inside content variable, channel is for source (model) or type of content
        request is for what you want to do with content
        room is for what users to you want to spread this info
      */

      if (!((this.content.id != null) || this.content.query)) {
        this.content.id = SocketEvent.genId();
      }
    }

    SocketEvent.makeEvent = function(content, channel, req, room) {
      if (room == null) {
        room = "all";
      }
      /*
        creates a socketevent, where:
        content is content of event
        channel is name of the channel that is used for this event
        req is a request with what this event is send
        room is an info to which users should the event be sent to
      */

      return new Batman.SocketEvent(content, channel, req, room);
    };

    SocketEvent.makePushEvent = function(content, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent(content, channel, "push", room);
    };

    SocketEvent.makeReadEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "read", room);
    };

    SocketEvent.makeReadAllEvent = function(channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        query: "all"
      }, channel, "read", room);
    };

    SocketEvent.makeSaveEvent = function(obj, channel) {
      var data;
      data = Batman.SocketEvent.fromData(obj);
      data.channel = channel;
      data.request = "save";
      data.room = "all";
      return data;
    };

    SocketEvent.makeRemoveEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "delete", room);
    };

    SocketEvent.fromEvent = function(event) {
      /*
      factory that generate SocketEvent from websocket event
      */
      if (event instanceof Batman.SocketEvent) {
        return event;
      }
      if (event.data == null) {
        throw new Error("No data inside of websocket event");
      }
      return this.fromData(event.data);
    };

    SocketEvent.genId = function() {
      /*
      ##Generates GUI as id for a record
      */
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    SocketEvent.fromData = function(data) {
      /*
      factory that generate SocketEvent from the data
      */

      var channel, content, request;
      if (data instanceof Batman.SocketEvent) {
        return data;
      }
      if (typeof data === "string") {
        return this.fromString(data);
      }
      if (data.data != null) {
        data = data.data;
      }
      channel = data.channel != null ? data.channel : "default";
      content = data.content != null ? typeof data.content === "string" ? this.toJSON(data.content) : data.content : data;
      request = data.request != null ? data.request : "push";
      return new Batman.SocketEvent(content, channel, request);
    };

    SocketEvent.fromString = function(str) {
      /*
      factory that generate SocketEvent from some string
      */

      var data;
      data = this.toJSON(str);
      if (data === void 0 || typeof data === "string") {
        return new Batman.SocketEvent(str, "default", "save");
      } else {
        return this.fromData(data);
      }
    };

    SocketEvent.toJSON = function(str) {
      /*
      tries to convert string to json, returns initial string if failed
      */

      var obj;
      if (typeof str !== "string") {
        return str;
      }
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return str;
      }
      if (obj === void 0) {
        return str;
      } else {
        return obj;
      }
    };

    return SocketEvent;

  })();

  /*
  # WorkerSocket class #
  */


  Batman.WorkerSocket = (function(_super) {

    __extends(WorkerSocket, _super);

    /*
    #Worker socket#
    */


    function WorkerSocket(worker) {
      var _this = this;
      this.send = function(obj) {
        return WorkerSocket.prototype.send.apply(_this, arguments);
      };
      if (typeof worker === "string") {
        this.worker = worker = new SharedWorker(worker);
      } else {
        this.worker = worker;
      }
      this.worker.port.onmessage = function(e) {
        return _this.onmessage(e);
      };
      this.worker.port.onerror = function(e) {
        return _this.onerror(e);
      };
      Batman.container.worker = this.worker;
      this.worker.port.start();
      Batman.WorkerSocket.instance = this;
    }

    WorkerSocket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      if (Batman.WorkerSocket.instance != null) {
        return Batman.WorkerSocket.instance;
      } else {
        return new Batman.WorkerSocket(url);
      }
    };

    WorkerSocket.prototype.send = function(obj) {
      return this.worker.port.postMessage(obj);
    };

    WorkerSocket.prototype.onopen = function(i) {};

    WorkerSocket.prototype.onerror = function(error) {};

    WorkerSocket.prototype.onmessage = function(event) {
      var data;
      data = event.data != null ? event.data : event;
      if (data.ready != null) {
        return onopen(data);
      }
    };

    WorkerSocket.prototype.onclose = function() {};

    return WorkerSocket;

  })(Batman.Object);

  /*
  # MockSocket class #
  Mock socket is needed for tests to simulate websocket behaviour
  */


  Batman.MockSocket = (function(_super) {

    __extends(MockSocket, _super);

    /*
    #Mock socket#
    Mock socket is needed for tests to simulate websocket behaviour
    */


    function MockSocket(url) {
      var _this = this;
      this.url = url;
      this.randomInt = function(min, max) {
        return MockSocket.prototype.randomInt.apply(_this, arguments);
      };
      this.onclose = function() {
        return MockSocket.prototype.onclose.apply(_this, arguments);
      };
      this.send = function(event) {
        return MockSocket.prototype.send.apply(_this, arguments);
      };
      this.onreceive = Batman.MockSocket.mockCallback(this);
      MockSocket.instance = this;
    }

    MockSocket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      if (Batman.MockSocket.instance != null) {
        return Batman.MockSocket.instance;
      } else {
        return new Batman.MockSocket(url);
      }
    };

    MockSocket.prototype.isMock = true;

    MockSocket.prototype.onreceive = function(event) {
      return event;
    };

    MockSocket.prototype.send = function(event) {
      return this.onreceive(event);
    };

    MockSocket.prototype.onopen = function() {
      /*
      Open event
      */
      return console.log("open");
    };

    MockSocket.prototype.onmessage = function(event) {
      /*
      On message
      */

      var data;
      return data = event.data;
    };

    MockSocket.prototype.onclose = function() {
      return console.log("close");
    };

    MockSocket.prototype.randomInt = function(min, max) {
      /*
        random int generating function
      */
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    MockSocket.mockCallback = function(mock) {
      /*
        this callback is needed to store data inside mock sockets and respond to read requests and other queirs
        NAPILNIK
      */
      return function(event) {
        var all, col, content, data, id, message, res;
        data = Batman.SocketEvent.fromString(event);
        switch (data.request) {
          case "save":
            /*
              if we received request to save something we answer to it with result
            */

            data.request = "push";
            if (data.content.id != null) {
              id = data.content.id;
              /*
                if we were give id we just give item with appropriate id
              */

              mock.set(id, data);
              all = mock.getOrSet(data.channel, function() {
                return new Batman.SimpleSet();
              });
              res = all.find(function(item) {
                return item.id === id;
              });
              if (res != null) {
                all.remove(res);
              }
              all.add(data.content);
              return mock.onmessage(data);
            }
            break;
          case "delete":
            if (data.content.id != null) {
              id = data.content.id;
              mock.unset(id);
              all = mock.getOrSet(data.channel, function() {
                return new Batman.SimpleSet();
              });
              res = all.find(function(item) {
                return item.id === id;
              });
              if (res != null) {
                return all.remove(res);
              }
            }
            break;
          case "read":
            if (data.content.id != null) {
              data = mock.get(data.content.id);
              data.request = "answer";
              return mock.onmessage(data);
            } else {
              if ((data.content.query != null) && data.content.query === "all") {
                col = mock.get(data.channel);
                if ((col != null) && col.length > 0) {
                  content = col.toArray();
                  message = new Batman.SocketEvent(content, data.channel, "readAll");
                  return mock.onmessage(message);
                } else {
                  return mock.onmessage(new Batman.SocketEvent("_nil_", data.channel, "readAll"));
                }
              }
            }
        }
      };
    };

    return MockSocket;

  }).call(this, Batman.Object);

  /*
  # MockSocket class #
  Mock socket is needed for tests to simulate websocket behaviour
  */


  Batman.CacheSocket = (function(_super) {

    __extends(CacheSocket, _super);

    /*
    	#Cache socket#
    	Cache socket is needed to collect the data before real websocket is connected
    */


    function CacheSocket(url) {
      var _this = this;
      this.url = url;
      this.unapply = function(successor) {
        return CacheSocket.prototype.unapply.apply(_this, arguments);
      };
      this.randomInt = function(min, max) {
        return CacheSocket.prototype.randomInt.apply(_this, arguments);
      };
      this.onclose = function() {
        return CacheSocket.prototype.onclose.apply(_this, arguments);
      };
      this.onerror = function() {
        return CacheSocket.prototype.onerror.apply(_this, arguments);
      };
      this.send = function(data) {
        return CacheSocket.prototype.send.apply(_this, arguments);
      };
      this.input = new Array();
      CacheSocket.__super__.constructor.apply(this, arguments);
    }

    CacheSocket.prototype.isMock = true;

    CacheSocket.prototype.isCache = true;

    CacheSocket.prototype.input = [];

    CacheSocket.prototype.send = function(data) {
      return this.input.push(data);
    };

    CacheSocket.prototype.onopen = function() {
      /*
      		Open event
      */
      return console.log("open");
    };

    CacheSocket.prototype.onmessage = function(event) {
      /*
      		On message
      */

      var data;
      data = event.data;
      return console.log(data);
    };

    CacheSocket.prototype.onerror = function() {
      return console.log("error");
    };

    CacheSocket.prototype.onclose = function() {
      return console.log("close");
    };

    CacheSocket.prototype.randomInt = function(min, max) {
      /*
      			random int generating function
      */
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    CacheSocket.prototype.unapply = function(successor) {
      var el, _i, _len, _ref, _results;
      if ((this.input != null) && (successor.send != null)) {
        _ref = this.input;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(successor.send(el));
        }
        return _results;
      }
    };

    return CacheSocket;

  })(Batman.Object);

  /*
  # Channel class #
  Every sockets info to channels.
  Channels are needed to communicate directly with the model
  */


  Batman.Channel = (function(_super) {

    __extends(Channel, _super);

    /*
    #Channel class
    Every sockets info to channels.
    Channels are needed to communicate directly with the model
    */


    function Channel(name) {
      var _this = this;
      this.attach = function(obj) {
        return Channel.prototype.attach.apply(_this, arguments);
      };
      this.ask = function(question) {
        return Channel.prototype.ask.apply(_this, arguments);
      };
      this.onmessage = function(event) {
        return Channel.prototype.onmessage.apply(_this, arguments);
      };
      this.onNextMessage = function(fun) {
        return Channel.prototype.onNextMessage.apply(_this, arguments);
      };
      this.receive = function(event) {
        return Channel.prototype.receive.apply(_this, arguments);
      };
      this.send = function(obj) {
        return Channel.prototype.send.apply(_this, arguments);
      };
      this.remove = function(id) {
        return Channel.prototype.remove.apply(_this, arguments);
      };
      this.readAll = function() {
        return Channel.prototype.readAll.apply(_this, arguments);
      };
      this.read = function(id) {
        return Channel.prototype.read.apply(_this, arguments);
      };
      this.save = function(obj) {
        return Channel.prototype.save.apply(_this, arguments);
      };
      this.save = function(obj, id) {
        return Channel.prototype.save.apply(_this, arguments);
      };
      this.name = name;
      this.on("onmessage", function(event) {
        return _this.onmessage(event);
      });
    }

    Channel.prototype.save = function(obj, id) {
      obj.id = id;
      return this.save(obj);
    };

    Channel.prototype.save = function(obj) {
      return this.fire("send", Batman.SocketEvent.makeSaveEvent(obj, this.name));
    };

    Channel.prototype.read = function(id) {
      return this.fire("send", Batman.SocketEvent.makeReadEvent(id, this.name));
    };

    Channel.prototype.readAll = function() {
      return this.fire("send", Batman.SocketEvent.makeReadAllEvent(this.name));
    };

    Channel.prototype.remove = function(id) {
      return this.fire("send", Batman.SocketEvent.makeRemoveEvent(id, this.name));
    };

    Channel.prototype.send = function(obj) {
      var data;
      data = Batman.SocketEvent.fromData(obj);
      data.channel = this.name;
      return this.fire("send", data);
    };

    Channel.prototype.receive = function(event) {
      return this.fire("onmessage", event);
    };

    Channel.prototype.onNextMessage = function(fun) {
      var _this = this;
      return this.once("onmessage", function(event) {
        return fun(event);
      });
    };

    Channel.prototype.onmessage = function(event) {
      /*
        call back the receives info from socket send to this channel
      */

    };

    Channel.prototype.ask = function(question) {
      /*
        asks router for some additional info
      */
      return this.fire("ask", question);
    };

    Channel.prototype.attach = function(obj) {
      /*
        Attaches the channel to the socket wrapper and subscribes to its events
      */

      var receive, send;
      receive = this.receive;
      obj.on(this.name, receive);
      obj.on("all", receive);
      send = obj.send;
      this.on("send", send);
      this.on("ask", obj.ask);
      return this;
    };

    return Channel;

  })(Batman.Object);

  /*
    video channel class, temporal version
    will be refactored in the future
  */


  Batman.VideoChannel = (function(_super) {

    __extends(VideoChannel, _super);

    VideoChannel.prototype.peer = null;

    /*
      mystream is a temporal global variable to save a stream from a webcome
    */


    function VideoChannel(name, room, myStream) {
      var _this = this;
      this.room = room;
      this.myStream = myStream != null ? myStream : null;
      this.attach = function(obj) {
        return VideoChannel.prototype.attach.apply(_this, arguments);
      };
      this.subscribeRemote = function(vid) {
        return VideoChannel.prototype.subscribeRemote.apply(_this, arguments);
      };
      this.subscribeLocal = function(vid) {
        return VideoChannel.prototype.subscribeLocal.apply(_this, arguments);
      };
      this.stream2src = function(stream) {
        return VideoChannel.prototype.stream2src.apply(_this, arguments);
      };
      this.onmessage = function(event) {
        return VideoChannel.prototype.onmessage.apply(_this, arguments);
      };
      this.onGetICE = function(event) {
        return VideoChannel.prototype.onGetICE.apply(_this, arguments);
      };
      this.onCreateICE = function(event) {
        return VideoChannel.prototype.onCreateICE.apply(_this, arguments);
      };
      this.onGetRemoteStream = function(e) {
        return VideoChannel.prototype.onGetRemoteStream.apply(_this, arguments);
      };
      this.onGetAnswer = function(event) {
        return VideoChannel.prototype.onGetAnswer.apply(_this, arguments);
      };
      this.onCreateAnswer = function(desc) {
        return VideoChannel.prototype.onCreateAnswer.apply(_this, arguments);
      };
      this.onGetOffer = function(event) {
        return VideoChannel.prototype.onGetOffer.apply(_this, arguments);
      };
      this.onCreateOffer = function(desc) {
        return VideoChannel.prototype.onCreateOffer.apply(_this, arguments);
      };
      this.call = function() {
        return VideoChannel.prototype.call.apply(_this, arguments);
      };
      this.onWebCamSuccess = function(stream) {
        return VideoChannel.prototype.onWebCamSuccess.apply(_this, arguments);
      };
      this.makePeer = function(servers) {
        if (servers == null) {
          servers = null;
        }
        return VideoChannel.prototype.makePeer.apply(_this, arguments);
      };
      this.startPeer = function(servers) {
        if (servers == null) {
          servers = null;
        }
        return VideoChannel.prototype.startPeer.apply(_this, arguments);
      };
      this.askWebcam = function() {
        return VideoChannel.prototype.askWebcam.apply(_this, arguments);
      };
      VideoChannel.__super__.constructor.call(this, name);
      this.startPeer();
    }

    VideoChannel.prototype.askWebcam = function() {
      return this.ask("webcam");
    };

    VideoChannel.prototype.startPeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      /*
      starts p2p connection
      */

      this.peer = this.makePeer();
      return this.peer.onicecandidate = this.onCreateICE;
    };

    VideoChannel.prototype.makePeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      if (window.RTCPeerConnection != null) {
        return new RTCPeerConnection(servers);
      } else {
        if (window.mozRTCPeerConnection != null) {
          return new mozRTCPeerConnection(servers);
        } else {
          return new webkitRTCPeerConnection(servers);
        }
      }
    };

    VideoChannel.prototype.onWebCamSuccess = function(stream) {
      /*
        when webcam stream received
      */
      this.myStream = stream;
      this.peer.addStream(stream);
      this.fire("localStream", stream);
      return this.peer.onaddstream = this.onGetRemoteStream;
    };

    VideoChannel.prototype.call = function() {
      /*
        Makes a call
      */
      if (this.myStream != null) {
        return this.peer.createOffer(this.onCreateOffer);
      } else {
        this.askWebcam();
        return this.on("localStream", this.call);
      }
    };

    VideoChannel.prototype.onCreateOffer = function(desc) {
      /*
        fires when you propose and offer
      */

      var offer;
      this.peer.setLocalDescription(desc);
      offer = Batman.SocketEvent.makeEvent(desc, this.name, "offer", this.room);
      return this.fire("send", offer);
    };

    VideoChannel.prototype.onGetOffer = function(event) {
      /*
        fires when you received another's offer
      */

      var desc;
      desc = new RTCSessionDescription(event);
      this.peer.setRemoteDescription(desc);
      return this.peer.createAnswer(this.onCreateAnswer);
    };

    VideoChannel.prototype.onCreateAnswer = function(desc) {
      /*
        fires when you created an answer
      */

      var answer;
      this.peer.setLocalDescription(desc);
      answer = Batman.SocketEvent.makeEvent(desc, this.name, "answer", this.room);
      return this.fire("send", answer);
    };

    VideoChannel.prototype.onGetAnswer = function(event) {
      /*
        fires when you received an answer
      */

      var desc;
      desc = new RTCSessionDescription(event);
      return this.peer.setRemoteDescription(desc);
    };

    VideoChannel.prototype.onGetRemoteStream = function(e) {
      /*
        fires when you got stream
      */

      var stream;
      if (e.stream != null) {
        stream = e.stream;
        return this.fire("remoteStream", stream);
      } else {
        return alert("bug in onGetRemoteStream");
      }
    };

    VideoChannel.prototype.onCreateICE = function(event) {
      /*
        fires when you make an ICE candidates
      */

      var cand, evt;
      if (event.candidate != null) {
        cand = event.candidate;
        evt = Batman.SocketEvent.makeEvent(cand, this.name, "ICE", this.room);
        return this.fire("send", evt);
      }
      /*
      else
        alert "onICE do not work well"
        alert JSON.stringify(event)
      */

    };

    VideoChannel.prototype.onGetICE = function(event) {
      /*
        fires when you received and ICE
      */
      return this.peer.addIceCandidate(new RTCIceCandidate(event));
    };

    VideoChannel.prototype.onmessage = function(event) {
      /*
        on message event handler
      */
      switch (event.request) {
        case "ICE":
          return this.onGetICE(event.content);
        case "offer":
          return this.onGetOffer(event.content);
        case "answer":
          return this.onGetAnswer(event.content);
      }
    };

    VideoChannel.prototype.onError = function(e) {
      return alert("There has been a problem retrieving the streams - did you allow access?");
    };

    VideoChannel.prototype.stream2src = function(stream) {
      /*
        gets URL from the stream
      */
      if (window.URL != null) {
        return window.URL.createObjectURL(stream);
      } else {
        if (window.webkitURL != null) {
          return window.webkitURL.createObjectURL(stream);
        } else {
          if (window.mozURL != null) {
            return window.mozURL.createObjectURL(stream);
          } else {
            return stream;
          }
        }
      }
    };

    VideoChannel.prototype.subscribeLocal = function(vid) {
      var _this = this;
      return this.on("localStream", function(stream) {
        return vid.src = _this.stream2src(stream);
      });
    };

    VideoChannel.prototype.subscribeRemote = function(vid) {
      var _this = this;
      return this.on("remoteStream", function(stream) {
        return vid.src = _this.stream2src(stream);
      });
    };

    VideoChannel.prototype.attach = function(obj) {
      var onStream;
      onStream = this.onWebCamSuccess;
      obj.on("localStream", onStream);
      VideoChannel.__super__.attach.call(this, obj);
      if (this.myStream != null) {
        this.peer.addStream(this.myStream);
        this.peer.onaddstream = this.onGetRemoteStream;
      } else {
        this.askWebcam();
      }
      return this;
    };

    return VideoChannel;

  })(Batman.Channel);

  /*
    Routerclass
  */


  Batman.SimpleRouter = (function(_super) {

    __extends(SimpleRouter, _super);

    function SimpleRouter() {
      return SimpleRouter.__super__.constructor.apply(this, arguments);
    }

    /*
      Simple router does only simple broadcasting relying on channel info from the socket
    */


    SimpleRouter.prototype.broadcast = function(info, socket) {
      /*
        transforms info into SocketEvents and routes them further, to the channels
        some routers split info into several parts and send to difference channels
      */

      var event;
      event = Batman.SocketEvent.fromEvent(info);
      /* broadcasts the message further
      */

      if (!(event instanceof Batman.SocketEvent)) {
        throw Error('should be socket event');
      }
      /* broadcast event to appropriate channels
      */

      return socket.fire(event.channel, event);
    };

    SimpleRouter.prototype.send = function(obj, websocket) {
      /*
        sends event to the websocket
      */

      var str;
      if (typeof obj === 'string') {
        return websocket.send(obj);
      } else {
        str = JSON.stringify(Batman.SocketEvent.fromData(obj));
        return websocket.send(str);
      }
    };

    SimpleRouter.prototype.myStream = null;

    SimpleRouter.prototype.webCamPending = false;

    SimpleRouter.prototype.respond = function(question, socket) {
      /*
        respond to questions from channels
      */

      var onerror, onsuccess,
        _this = this;
      switch (question) {
        case "webcam":
          if (this.myStream != null) {
            return socket.fire("localStream", this.myStream);
          } else {
            if (this.webCamPending === false) {
              navigator.getUserMedia || (navigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia);
              if (navigator.getUserMedia) {
                onsuccess = function(stream) {
                  socket.fire("localStream", stream);
                  return _this.webCamPending = false;
                };
                onerror = this.onError;
                this.webCamPending = true;
                navigator.getUserMedia({
                  video: true,
                  audio: true
                }, onsuccess, onerror);
              } else {
                alert("getUserMedia is not supported in this browser.");
              }
            }
            return this.webCamPending = true;
          }
      }
    };

    return SimpleRouter;

  })(Batman.Object);

  /*
    Chat router class
  */


  Batman.ChatRouter = (function(_super) {

    __extends(ChatRouter, _super);

    function ChatRouter() {
      return ChatRouter.__super__.constructor.apply(this, arguments);
    }

    ChatRouter.prototype.broadcast = function(info, socket) {
      /*
        routes events to the chat
      */

      var data;
      if (info.data == null) {
        return ChatRouter.__super__.broadcast.call(this, info, socket);
      }
      if (info.data.content != null) {
        return ChatRouter.__super__.broadcast.call(this, info, socket);
      }
      data = Batman.SocketEvent.toJSON(info.data);
      if (data.kind != null) {
        switch (data.kind) {
          case "join":
            this.addUser(data, socket);
            return this.message(data, socket);
          case "quit":
            this.removeUser(data, socket);
            return this.message(data, socket);
          case "talk":
            return this.message(data, socket);
          case "message":
            return this.message(data, socket);
        }
      }
    };

    ChatRouter.prototype.addUser = function(data, socket) {
      var content, event;
      content = {
        id: data.user,
        name: data.user
      };
      event = new Batman.SocketEvent.makePushEvent(content, "users");
      return socket.fire("users", event);
    };

    ChatRouter.prototype.removeUser = function(data, socket) {
      return socket.fire("users", Batman.SocketEvent.makeRemoveEvent(data.user, "users"));
    };

    ChatRouter.prototype.message = function(data, socket) {
      var content, event, text;
      text = data.message != null ? data.message : data.text;
      content = {
        "user": data.user,
        "text": text
      };
      event = Batman.SocketEvent.makePushEvent(content, "messages");
      return socket.fire("messages", event);
    };

    ChatRouter.prototype.task = function(data, socket) {
      var content, event;
      content = {
        "user": data.user,
        "title": data.title
      };
      event = Batman.SocketEvent.makePushEvent(content, "tasks");
      return socket.fire("tasks", event);
    };

    ChatRouter.prototype.send = function(obj, websocket) {
      /*
        sends event to the websocket
      */

      var event, str;
      if (typeof obj === 'string') {
        return websocket.send(obj);
      } else {
        event = Batman.SocketEvent.fromData(obj);
        if (event.channel === "messages") {
          if (event.content != null) {
            if (event.content.text != null) {
              event.text = event.content.text;
            } else {
              if (event.content.data != null) {
                event.text = event.content.data;
              } else {
                event.text = event.content;
              }
            }
          }
        }
        str = JSON.stringify(Batman.SocketEvent.fromData(obj));
        return websocket.send(str);
      }
    };

    return ChatRouter;

  })(Batman.SimpleRouter);

  /*
    #Socket class#
    it not only uses either real or mock socket but broadcasts messages to various channels through events
  */


  Batman.Socket = (function(_super) {

    __extends(Socket, _super);

    /*
      websocket wrapper that broadcast info to its channels
      it not only uses either real or mock socket but broadcasts messages to various channels through events
    */


    function Socket(url) {
      var _this = this;
      this.ask = function(question) {
        return Socket.prototype.ask.apply(_this, arguments);
      };
      this.send = function(obj) {
        return Socket.prototype.send.apply(_this, arguments);
      };
      this.getVideoChannel = function(name, room) {
        return Socket.prototype.getVideoChannel.apply(_this, arguments);
      };
      this.getSpecialChannel = function(name, factory) {
        return Socket.prototype.getSpecialChannel.apply(_this, arguments);
      };
      this.getChannel = function(name) {
        return Socket.prototype.getChannel.apply(_this, arguments);
      };
      this.withUrl = function(url) {
        return Socket.prototype.withUrl.apply(_this, arguments);
      };
      this.getWebSocket = function(url) {
        return Socket.prototype.getWebSocket.apply(_this, arguments);
      };
      this.setWebsocket = function(websocket) {
        return Socket.prototype.setWebsocket.apply(_this, arguments);
      };
      this.createWebSocket = function(url) {
        return Socket.prototype.createWebSocket.apply(_this, arguments);
      };
      this.isMock = function() {
        return Socket.prototype.isMock.apply(_this, arguments);
      };
      /*
      creates a socket object
      */

      this.router = new Batman.SimpleRouter();
      this.websocket = this.getWebSocket(url);
      Batman.Socket.instance = this;
    }

    Socket.prototype.url = "none";

    Socket.prototype.isMock = function() {
      return (this.websocket == null) || (this.websocket.isMock != null);
    };

    Socket.prototype.createWebSocket = function(url) {
      /*
        creates websocket or mocksocket
      */

      var websocket;
      if (url === "none") {
        websocket = new Batman.CacheSocket(url);
      } else {
        websocket = new WebSocket(url);
      }
      this.url = url;
      return this.setWebsocket(websocket);
    };

    Socket.prototype.setWebsocket = function(websocket) {
      var old,
        _this = this;
      if (this.websocket != null) {
        if (websocket === this.websocket) {
          return this.websocket;
        }
        if (this.websocket.isCache != null) {
          old = this.websocket;
        }
      }
      this.websocket = websocket;
      this.websocket.onmessage = function(event) {
        return _this.broadcast(event);
      };
      this.websocket.onerror = function(err) {
        return alert("some ERROR occured");
      };
      this.websocket.onclose = function() {
        return alert("socket is CLOSED");
      };
      if ((old != null) && (websocket != null)) {
        old.unapply(this);
      }
      return this.websocket;
    };

    Socket.prototype.broadcast = function(info) {
      return this.router.broadcast(info, this);
    };

    Socket.prototype.getWebSocket = function(url) {
      /*
        TODO: rewrite, all this searches, the global scope only confuses
      */
      if (Batman.container.websocket != null) {
        if ((Batman.container.websocket.isMock && url === 'none') || url === this.url) {
          return Batman.container.websocket;
        }
      }
      return this.createWebSocket(url);
    };

    Socket.prototype.withUrl = function(url) {
      /*
        returns self but changes the websocket if needed
      */
      if (url !== this.url) {
        this.websocket = this.getWebSocket(url);
      }
      return this;
    };

    Socket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      /*
        works as singletone
        TODO: rewrite
      */

      if (Batman.Socket.instance != null) {
        return Batman.Socket.instance;
      } else {
        return new Batman.Socket(url);
      }
      /*
      if Batman.container.socket?
        return Batman.container.socket.withUrl(url)
      else
        return new Batman.Socket(url)
      */

    };

    Socket.prototype.getChannel = function(name) {
      /*
        gets or creates channel
      */

      var _this = this;
      return this.getOrSet(name, function() {
        return new Batman.Channel(name).attach(_this);
      });
    };

    Socket.prototype.getSpecialChannel = function(name, factory) {
      /*
        gets or creates channel with factory that is provided
      */

      var _this = this;
      return this.getOrSet(name, function() {
        return factory().attach(_this);
      });
    };

    Socket.prototype.getVideoChannel = function(name, room) {
      /*
        gets or creates video channel
      */

      var _this = this;
      return this.getOrSet(name, function() {
        return new Batman.VideoChannel(name, room).attach(_this);
      });
    };

    Socket.prototype.send = function(obj) {
      return this.router.send(obj, this.websocket);
    };

    Socket.prototype.ask = function(question) {
      /*
        executes if there is a request to the router (but without info to be send to server)
      */
      return this.router.respond(question, this);
    };

    return Socket;

  }).call(this, Batman.Object);

  /*
  #SocketStorage#
  
  This is a Socket storage adaptor needed to connect Batman's models to websocket
  It has not been finished yet.
  */


  Batman.SocketStorage = (function(_super) {

    __extends(SocketStorage, _super);

    /*
    #SocketStorage#
    
    This is a Socket storage adaptor needed to connect Batman's models to websocket
    It has not been finished yet.
    */


    function SocketStorage(model) {
      /*
        Initialize storage adaptor as well as socket
      */
      SocketStorage.__super__.constructor.call(this, model);
      this.socket = new Batman.Socket.getInstance();
    }

    SocketStorage.prototype._dataMatches = function(conditions, data) {
      var k, match, v;
      match = true;
      for (k in conditions) {
        v = conditions[k];
        if (data[k] !== v) {
          match = false;
          break;
        }
      }
      return match;
    };

    SocketStorage.prototype.subscribe = function(model) {
      /*
        Subscribe model to different events
      */

      var channel,
        _this = this;
      channel = this.socket.getChannel(model.storageKey);
      channel.onmessage = function(event) {
        var all, record, res;
        all = model.get("loaded");
        switch (event.request) {
          case "push":
            res = all.find(function(item) {
              return item.id === event.content.id;
            });
            if (res != null) {
              all.remove(res);
            }
            record = _this.getRecordFromData(event.content, model);
            return all.add(record);
          case "delete":
            res = all.find(function(item) {
              return item.id === event.content.id;
            });
            if (res != null) {
              return all.remove(res);
            }
        }
      };
      return channel;
    };

    SocketStorage.prototype.readAll = function(env, next) {
      /*
      overrided readAll to add subscription
      */

      var channel, options;
      channel = this.subscribe(env.subject);
      options = env.options.data;
      channel.onNextMessage(function(event) {
        var item, records, _i, _len, _ref;
        try {
          records = [];
          if ((event.content != null) && (event.content.length != null)) {
            _ref = event.content;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (this._dataMatches(options, item)) {
                records.push(item);
              }
            }
          }
          env.recordsAttributes = records;
        } catch (error) {
          env.error = error;
        }
        return next();
      });
      return channel.readAll();
    };

    SocketStorage.prototype.create = function(_arg, next) {
      var channel, id, key, recordAttributes;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.read = function(_arg, next) {
      var channel, id, key, recordAttributes,
        _this = this;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.onNextMessage(function() {
        if (!env.recordAttributes) {
          env.error = new _this.constructor.NotFoundError();
          return next();
        }
      });
      return channel.read(id);
    };

    SocketStorage.prototype.update = function(_arg, next) {
      var channel, id, key, recordAttributes;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.destroy = function(_arg, next) {
      var channel, id, key;
      key = _arg.key, id = _arg.id;
      channel = this.socket.getChannel(key);
      channel.remove(id);
      return next();
    };

    SocketStorage.prototype.before('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      var key,
        _this = this;
      if (env.action === 'create') {
        env.id = env.subject.get('id') || env.subject._withoutDirtyTracking(function() {
          return env.subject.set('id', Batman.SocketEvent.genId());
        });
      } else {
        env.id = env.subject.get('id');
      }
      if (env.id == null) {
        env.error = new this.constructor.StorageError("Couldn't get/set record primary key on " + env.action + "!");
      }
      key = this.storageKey(env.subject);
      env.key = key;
      return next();
    }));

    SocketStorage.prototype.before('create', 'update', SocketStorage.skipIfError(function(env, next) {
      env.recordAttributes = JSON.stringify(env.subject);
      return next();
    }));

    SocketStorage.prototype.after('read', SocketStorage.skipIfError(function(env, next) {
      if (typeof env.recordAttributes === 'string') {
        try {
          env.recordAttributes = this._jsonToAttributes(env.recordAttributes);
        } catch (error) {
          env.error = error;
          return next();
        }
      }
      env.subject._withoutDirtyTracking(function() {
        return this.fromJSON(env.recordAttributes);
      });
      return next();
    }));

    SocketStorage.prototype.after('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      env.result = env.subject;
      return next();
    }));

    SocketStorage.prototype.after('readAll', SocketStorage.skipIfError(function(env, next) {
      var recordAttributes;
      env.result = env.records = (function() {
        var _i, _len, _ref, _results;
        _ref = env.recordsAttributes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          recordAttributes = _ref[_i];
          _results.push(this.getRecordFromData(recordAttributes, env.subject));
        }
        return _results;
      }).call(this);
      return next();
    }));

    return SocketStorage;

  })(Batman.StorageAdapter);

}).call(this);
