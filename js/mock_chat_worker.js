//@ sourceMappingURL=mock_chat_worker.map
// Generated by CoffeeScript 1.6.1
(function() {
  var AbstractSocketWorker, BasicWorker, MockWorker, SocketWorker, worker,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  AbstractSocketWorker = (function() {

    function AbstractSocketWorker() {
      var _this = this;
      this.broadcast = function(data) {
        return AbstractSocketWorker.prototype.broadcast.apply(_this, arguments);
      };
      this.notifyAll = function(data) {
        return AbstractSocketWorker.prototype.notifyAll.apply(_this, arguments);
      };
      this.listenAll = function(fun) {
        return AbstractSocketWorker.prototype.listenAll.apply(_this, arguments);
      };
      this.postMessage = function(data) {
        return AbstractSocketWorker.prototype.postMessage.apply(_this, arguments);
      };
      this.connections = 0;
      this.ports = [];
    }

    AbstractSocketWorker.prototype.connections = 0;

    AbstractSocketWorker.prototype.connect = function(e) {
      this.lastPort = e.ports[0];
      this.ports.push(this.lastPort);
      return this.connections++;
    };

    AbstractSocketWorker.prototype.postMessage = function(data) {
      return this.lastPort.postMessage(data);
    };

    AbstractSocketWorker.prototype.listenAll = function(fun) {
      var num, port, _results;
      if (!((this.ports != null) || this.ports.length === 0)) {
        return;
      }
      num = 0;
      _results = [];
      while (num < this.ports.length) {
        port = this.ports[num];
        port.onmessage = function(e) {
          return fun(e);
        };
        _results.push(num++);
      }
      return _results;
    };

    AbstractSocketWorker.prototype.notifyAll = function(data) {
      var num, port, _results;
      if (!((this.ports != null) || this.ports.length === 0)) {
        return;
      }
      num = 0;
      _results = [];
      while (num < this.ports.length) {
        port = this.ports[num];
        port.postMessage(data);
        _results.push(num++);
      }
      return _results;
    };

    AbstractSocketWorker.prototype.broadcast = function(data) {
      var num, port, _results;
      num = 0;
      _results = [];
      while (num < this.ports.length) {
        port = this.ports[num];
        port.postMessage(data);
        _results.push(num++);
      }
      return _results;
    };

    return AbstractSocketWorker;

  })();

  MockWorker = (function(_super) {

    __extends(MockWorker, _super);

    function MockWorker() {
      var _this = this;
      this.generate = function() {
        return MockWorker.prototype.generate.apply(_this, arguments);
      };
      this.randomInt = function(min, max) {
        return MockWorker.prototype.randomInt.apply(_this, arguments);
      };
      this.onclose = function() {
        return MockWorker.prototype.onclose.apply(_this, arguments);
      };
      this.send = function(e) {
        return MockWorker.prototype.send.apply(_this, arguments);
      };
      this.sendBack = function(d) {
        return MockWorker.prototype.sendBack.apply(_this, arguments);
      };
      this.onmessage = function(event) {
        return MockWorker.prototype.onmessage.apply(_this, arguments);
      };
      this.onopen = function() {
        return MockWorker.prototype.onopen.apply(_this, arguments);
      };
      return MockWorker.__super__.constructor.apply(this, arguments);
    }

    /*
      It is mock version of Basicworker
    */


    MockWorker.prototype.onopen = function() {};

    MockWorker.prototype.onmessage = function(event) {};

    MockWorker.prototype.sendBack = function(d) {
      /*
        swaps room and channel ans sends data back
        it is needed for p2p testing
      */

      var newChannel;
      newChannel = d.room;
      d.room = d.channel;
      d.channel = newChannel;
      if (this.websocket != null) {
        return this.websocket.onmessage({
          data: d
        });
      }
    };

    MockWorker.prototype.send = function(e) {
      var data, req;
      data = JSON.parse(e);
      req = data.request;
      if (req === "sendback" || req === "answer" || req === "offer" || req === "ICE") {
        return this.sendBack(data);
      }
    };

    MockWorker.prototype.onclose = function() {};

    MockWorker.prototype.createWebsocket = function(user, password, url) {
      if (url !== "none") {
        url = url.replace("none", user);
      }
      this.generate();
      return this;
    };

    MockWorker.prototype.randomInt = function(min, max) {
      /*
        random int generating function
      */
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    MockWorker.prototype.generate = function() {
      /*
        callback that generates mock data (one of two test objects each second)
      */

      var len, message, r;
      len = this.arr.length - 1;
      r = this.randomInt(0, len);
      message = this.arr[r];
      if (this.websocket != null) {
        this.websocket.onmessage(message);
      }
      return setTimeout(this.generate, 2500);
    };

    return MockWorker;

  })(AbstractSocketWorker);

  BasicWorker = (function(_super) {

    __extends(BasicWorker, _super);

    /*
      It is mockworker created to test the chat data
    */


    function BasicWorker() {
      var focus, mycode, robot;
      BasicWorker.__super__.constructor.call(this);
      robot = {
        data: {
          content: {
            text: 'I am still alive!',
            user: "Robot"
          },
          request: "push",
          channel: "messages"
        }
      };
      mycode = {
        data: {
          content: {
            text: "Hi, guys! Look at my code!",
            user: "Anton"
          },
          request: "push",
          channel: "messages"
        }
      };
      focus = {
        data: {
          content: {
            text: "Comrades, it is not our primary focus, let's go and continue writing grant application!",
            user: "coced"
          }
        }
      };
      this.arr = [robot, mycode, focus];
    }

    return BasicWorker;

  })(MockWorker);

  /*
    This is a shared worker that containes websocket connection inside itself
    the connection is shared between several
  */


  SocketWorker = (function(_super) {

    __extends(SocketWorker, _super);

    function SocketWorker() {
      var _this = this;
      this.portHandler = function(msg) {
        return SocketWorker.prototype.portHandler.apply(_this, arguments);
      };
      this.sendAuth = function() {
        return SocketWorker.prototype.sendAuth.apply(_this, arguments);
      };
      this.hasAny = function(obj) {
        return SocketWorker.prototype.hasAny.apply(_this, arguments);
      };
      this.hasAuth = function(obj) {
        return SocketWorker.prototype.hasAuth.apply(_this, arguments);
      };
      this.hasLogin = function(obj) {
        return SocketWorker.prototype.hasLogin.apply(_this, arguments);
      };
      SocketWorker.__super__.constructor.apply(this, arguments);
    }

    SocketWorker.prototype.ports = [];

    SocketWorker.prototype.hasLogin = function(obj) {
      return (obj.user != null) && (obj.password != null);
    };

    SocketWorker.prototype.hasAuth = function(obj) {
      return this.hasLogin(obj) && (this.websocket != null);
    };

    SocketWorker.prototype.hasAny = function(obj) {
      return this.hasLogin(obj) || (obj.websocketURL != null) || this.connections > 0;
    };

    SocketWorker.prototype.connect = function(e) {
      /*
        connects to port
      */

      var _this = this;
      SocketWorker.__super__.connect.call(this, e);
      this.lastPort.onmessage = function(e) {
        return _this.portHandler(e);
      };
      return this.sendAuth();
    };

    SocketWorker.prototype.sendAuth = function() {
      /*
        authorizes other clients of this shared webworker
      */

      var message;
      message = {};
      if (this.url != null) {
        message.websocketURL = this.url;
      }
      if (this.user != null) {
        message.user = this.user;
      }
      if (this.password != null) {
        message.password = this.password;
      }
      if (this.websocket != null) {
        message.ready = true;
      }
      if (this.hasAny(this)) {
        return this.postMessage(message);
      }
    };

    SocketWorker.prototype.portHandler = function(msg) {
      var data, notifyAll, websocket;
      data = msg.data;
      if (data.user != null) {
        this.user = data.user;
      }
      if (data.password != null) {
        this.password = data.password;
      }
      if (data.websocketURL != null) {
        this.url = data.websocketURL;
      }
      if (this.websocket == null) {
        if ((this.url != null) && this.hasLogin(this)) {
          websocket = this.createWebsocket(this.user, this.password, this.url);
          this.websocket = websocket;
          notifyAll = this.notifyAll;
          websocket.onmessage = notifyAll;
          this.listenAll(function(e) {
            return websocket.send(e.data);
          });
        }
        /*
        if @url? and @hasLogin(@)
          websocket = @createWebsocket(@user,@password,@url)
          funMes = (e)=>
            event = e
            #debugger
            @notifyAll(e)
          @websocket = websocket
        
          websocket.onmessage = (e)->funMes(e.data)
          @listenAll (e)->
            #debugger
            websocket.send(e.data)
        */

      }
      return this.sendAuth();
    };

    return SocketWorker;

  })(BasicWorker);

  worker = new SocketWorker();

  self.addEventListener("connect", function(e) {
    return worker.connect(e);
  });

}).call(this);
